# 动态规划 - 划分型

### 题目一: *有一段由A-Z组成的字母串信息被加密成数字串。加密方式为：A->1,B->2,...,Z->26。给定加密后的字符串S[0...N-1],问有多少中方式解密成字符串？*

> 1. 确定状态
> - 给定一个加密的字符串后，我们将其划分为若干段数字，每段数字可以解密成一个字母。
> - 对于长度为N的加密后的字符串，从最后一步来说，若按一个位数进行划分，则方式数等于字符串前N-1的方式数；若按两位数进行划分，则方式数等于字符串前N-2的方式数。
> - $f[i]$表示字符串$s$前$i$个数字解密成字符的方式数。
>
> 2. 状态转移
> - 字符串S前i个数字解密成字母的方式数 = 前i-1个数字解密成字母的方式数 + 前i-2个数字解密成字母的方式数。
> - $f[i] = f[i-1] + f[i-2]$
> - 需要判断$s[i],s[i-1]s[i]$能否被解释为一个字母

#### 代码
```C++
#include<bits/stdc++.h>

using namespace std;

int f[105];

int main()
{
    string s;
    cin >> s;
    f[0] = 1;
    int len = s.length();
    for(int i=1;i<=len;i++){

        // 1位
        if( s[i-1] >= '0' && s[i-1] <= '9'){
            f[i] += f[i-1];
        }
        // 多位时 考虑2位
        if(i>1){
            int num = (s[i-2] - '0')*10 + (s[i-1]-'0');
            // 防止出现 01 -> A 的情况
            if(num > 9 && num < 27){
                f[i] += f[i-2];
            }
        }
    }
    cout << f[len] << endl;
    return 0;
}

```