# 动态规划-序列型

### *题目一：有一排N栋房子，每栋房子要漆成3种颜色中的一种:红、蓝、绿。任何两栋相邻的房子不能漆成同样的颜色。第i栋房子染成红色、蓝色、绿色的花费分别是$cost[i][0],cost[i][1],cost[i][2]$.问最少需要花多少钱油漆这些房子。*

> 1. 确定状态
> - 依据最初思想，确定第N栋房子的最小花费 = (前N-1种的最小花费 + 染第N栋房子的最小花费) && (第N栋房子的颜色 ！= 第N-1栋房子的颜色)
> - 我们不能判断第$i$栋房子的最小花费下是什么颜色的，因此需要把每栋房子染成红、蓝、绿的最小花费记录下来。
> - $f[i][0],f[i][1],f[i][2]$ 分别表示第$i$栋房子染成红色、蓝色、绿色的最小花费。
>
> 2. 状态转移
> - $f[i][j] = min \{ f[i-1][k_1] + a[i][j], f[i-1][k_2] + a[i][j] \}$;$j!=k_1,k_2$
> - 第$i$栋房子染成第$j$颜色的最小总花费等于第$i-1$栋房子染成$k$颜色的最小花费 + 第$i$栋房子染成第$j$个颜色的费用，其中$j!=k$,并在$k$区间内取最小值。

#### 代码
```C++
#include<bits/stdc++.h>

using namespace std;

int n;
int a[105][3];
int f[105][3];
const int MAX = 1e8;

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i][0] >> a[i][1] >> a[i][2];
    }
    f[0][0] = f[0][1] = f[0][2] = 0;
    for(int i=1;i<=n;i++){
        // 第i栋房子染为第j个颜色
        for(int j=0;j<3;j++){
            f[i][j] = MAX;
            // 第i-1栋房子染成第k个颜色的代价
            for(int k = 0;k<3;k++){
                // 颜色不一样
                if(j!=k){
                    f[i][j] = min(f[i][j], f[i-1][k] + a[i][j]);
                }
            }
        }
    }

    cout << min(f[n][0],min(f[n][1],f[n][2])) << endl;
    return 0;
}


```