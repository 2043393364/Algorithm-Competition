# 0-1背包型
## 1. [NOIP2001 普及组] 装箱问题

### 题目描述

有一个箱子容量为 $V$，同时有 $n$ 个物品，每个物品有一个体积。


现在从 $n$ 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。

### 输入格式

第一行共一个整数 $V$，表示箱子容量。

第二行共一个整数 $n$，表示物品总数。

接下来 $n$ 行，每行有一个正整数，表示第 $i$ 个物品的体积。

### 输出格式

- 共一行一个整数，表示箱子最小剩余空间。

### 样例 #1

#### 样例输入 #1

```
24
6
8
3
12
7
9
7
```

#### 样例输出 #1

```
0
```

#### 提示

对于 $100\%$ 数据，满足 $0<n \le 30$，$1 \le V \le 20000$。

### 题解
> - 此题属于0-1背包问题
> - 要求剩余空间尽可能小，只需尽可能的装最多
> - 直接排序向背包中装入物品未必得到的是最优解
> - 针对每个物品，我们只需要做出拿和不拿的决策并计算背包容量即可

#### (1) 正常思维实现的暴力递归
```C++
#include<bits/stdc++.h>

using namespace std;

int V,n;
int arrs[35];

int process(int index,int rest){

    if(index > n){
        return 0;
    }
    // 不选当前物品
    int p1 = process(index+1,rest);
    // 选当前物品
    int p2 = 0;
    // 如果有空间存储当前物品，则选
    if(rest-arrs[index]>=0){
        p2 = process(index+1,rest-arrs[index]) + arrs[index];
    }
    return max(p1,p2);
}


int main()
{
    cin >> V >> n;
    if(V<=0){
        cout<<0<<endl;
        return 0;
    }
    for(int i=1;i <= n;i++){
        cin >> arrs[i];
    }
    // 背包容量 - 最大存储容量
    cout<< V - process(1,V)<<endl;

    return 0;
}
```

#### (2) 动态规划代码
```C++
#include<bits/stdc++.h>

using namespace std;

int V,n;
int arrs[35];

int dp[20005];

int main()
{
    cin >> V >> n;
    if(V<=0){
        cout<<0<<endl;
        return 0;
    }
    for(int i=1;i <= n;i++){
        cin >> arrs[i];
    }
    for(int i=1;i<=n;i++){
        for(int j = V;j >= 0;j--){
            if(j - arrs[i] >= 0){
                dp[j] = max(dp[j],dp[j-arrs[i]]+arrs[i]);
            }
        }
    }

    // 背包容量 - 最大存储容量
    cout<< V - dp[V]<<endl;

    return 0;
}
```

## 2. [NOIP2006 普及组] 开心的金明

### 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过$N$元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的$N$元。于是，他把每件物品规定了一个重要度，分为$5$等：用整数$1-5$表示，第$5$等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过$N$元（可以等于$N$元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为$v[j]$，重要度为$w[j]$，共选中了$k$件物品，编号依次为$j_1,j_2,…,j_k$，则所求的总和为：

$v[j_1] \times w[j_1]+v[j_2] \times w[j_2]+ …+v[j_k] \times w[j_k]$。

请你帮助金明设计一个满足要求的购物单。

### 输入格式

第一行，为$2$个正整数，用一个空格隔开：$n,m$（其中$N(<30000)$表示总钱数，$m(<25)$为希望购买物品的个数。）

从第$2$行到第$m+1$行，第$j$行给出了编号为$j-1$的物品的基本数据，每行有$2$个非负整数$ v p$（其中$v$表示该物品的价格$(v \le 10000)$，$p$表示该物品的重要度($1-5$)

### 输出格式

$1$个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值$(<100000000)$。

### 样例 #1

#### 样例输入 #1

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

#### 样例输出 #1

```
3900
```

### 题解
#### (1) 暴力递归求解
```C++
#include<bits/stdc++.h>

using namespace std;
int n,m;
struct Node{
    int v,w;

}arrs[30];

int process(int index, int rest){
    if(index > m){
        return 0;
    }
    // 不选
    int p1 = process(index+1,rest);
    // 选
    int p2 = 0;
    // 如果选的决策有效
    if(rest - arrs[index].v >= 0){
        p2 = process(index+1,rest - arrs[index].v) + arrs[index].v * arrs[index].w;
    }
    return max(p1,p2);
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin >> arrs[i].v >> arrs[i].w;
    }
    cout << process(1,n);
    return 0;
}
```

#### (2) 动态规划代码
```C++
#include<bits/stdc++.h>

using namespace std;
int n,m;
struct Node{
    int v,w;

}arrs[30];

int dp[50005];

int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin >> arrs[i].v >> arrs[i].w;
    }
    for(int i = 1;i <= m;i++){
        for(int j = n;j>=0;j--){
            if(j-arrs[i].v >= 0){
                dp[j] = max(dp[j],dp[j-arrs[i].v] + arrs[i].v*arrs[i].w );
            }
        }
    }
    cout << dp[n];


    return 0;
}
```
